cmake_minimum_required(VERSION 3.18)
project(ASC_ODE_BLA LANGUAGES CXX)

# --- CI/pyodide: skip host-Python probing when cross-compiling to Emscripten ---
if(CMAKE_SYSTEM_NAME STREQUAL "Emscripten" OR CMAKE_CROSSCOMPILING)
  message(STATUS "Cross-compiling detected: disabling PYBIND11_FINDPYTHON and clearing Python variables to avoid host-Python vs cross-compiler checks.")

  # Force OFF so pybind11's CMake helpers won't try to find/validate host python
  set(PYBIND11_FINDPYTHON OFF CACHE BOOL "CI: do not find host python when cross-compiling" FORCE)

  # Also clear any Python executable / include / lib variables pybind11 or FindPython might consult.
  # Use CACHE + FORCE so we override any previously set values.
  set(PYBIND11_FINDPYTHON_EXECUTABLE "" CACHE FILEPATH "CI: no host python" FORCE)
  set(Python_EXECUTABLE "" CACHE FILEPATH "CI: no host python" FORCE)
  set(Python_INCLUDE_DIRS "" CACHE STRING "CI: empty" FORCE)
  set(Python_LIBRARIES "" CACHE STRING "CI: empty" FORCE)
endif()
# --- end guard ---

include(FetchContent)

# --- Ensure pybind11 is available as a subproject (avoid loading pybind11Config during cross-build) ---
include(FetchContent)

# Try to find an installed pybind11 first, but DO NOT load its pybind11Config if we're cross-compiling.
# Instead, fall back to fetching the source and adding it as a subdirectory so pybind11's internals
# respect the cache variables we set above (PYBIND11_FINDPYTHON OFF, etc).
find_package(pybind11 CONFIG QUIET)
if(pybind11_FOUND AND NOT (CMAKE_SYSTEM_NAME STREQUAL "Emscripten" OR CMAKE_CROSSCOMPILING))
  message(STATUS "Using installed pybind11 (config package)")
else()
  message(STATUS "Using FetchContent to provide pybind11 (ensures subproject build and no config probing)")
  FetchContent_Declare(
    pybind11
    GIT_REPOSITORY https://github.com/pybind/pybind11.git
    GIT_TAG        v2.10.4
  )
  FetchContent_MakeAvailable(pybind11)
endif()

# Allow caller to provide Python_EXECUTABLE on the cmake command line
#if(NOT DEFINED Python_EXECUTABLE)
#  find_program(Python_EXECUTABLE NAMES python3 python)
#endif()

# Detect cross-compilation for Emscripten
if(CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
  set(BUILDING_FOR_EMSCRIPTEN TRUE)
else()
  set(BUILDING_FOR_EMSCRIPTEN FALSE)
endif()

if(NOT BUILDING_FOR_EMSCRIPTEN)
  message(STATUS "Native build: locating Python interpreter + development files")
  # Native build: require interpreter + development (headers / embedding)
  find_package(Python COMPONENTS Interpreter Development REQUIRED)
else()
  message(STATUS "Cross build (Emscripten): using Python executable: ${Python_EXECUTABLE}")
  if(NOT Python_EXECUTABLE)
    message(FATAL_ERROR "Please provide -DPython_EXECUTABLE=/path/to/python when cross-compiling")
  endif()
  # Avoid attempting to link host Python libraries into wasm target:
  set(Python_EXECUTABLE ${Python_EXECUTABLE} CACHE FILEPATH "Host python executable")
  set(Python_INCLUDE_DIRS "" CACHE STRING "Empty when targeting Emscripten")
  set(Python_LIBRARIES "" CACHE STRING "Empty when targeting Emscripten")
endif()

set (CMAKE_CXX_STANDARD 17)
set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")

# --- Ensure pybind11 is present as a subproject when cross-compiling (avoid pybind11Config probing) ---
# If pybind11 is vendored as a submodule, use it. Otherwise, if we're doing a native build and
# an installed pybind11 config package is available, we can use that for speed. If cross-compiling,
# always use FetchContent to ensure the pybind11 subproject is built under our CMake context
# and respects the cache variables we set above (e.g. PYBIND11_FINDPYTHON OFF).
if(EXISTS "${CMAKE_SOURCE_DIR}/third_party/pybind11/CMakeLists.txt")
  message(STATUS "Using vendored pybind11 via add_subdirectory(${CMAKE_SOURCE_DIR}/third_party/pybind11)")
  add_subdirectory(${CMAKE_SOURCE_DIR}/third_party/pybind11)
else()
  if(NOT (CMAKE_SYSTEM_NAME STREQUAL "Emscripten" OR CMAKE_CROSSCOMPILING))
    # native build: prefer installed config package if present
    find_package(pybind11 CONFIG QUIET)
    if(pybind11_FOUND)
      message(STATUS "Using installed pybind11 (config package)")
    else()
      message(STATUS "Installed pybind11 not found: fetching via FetchContent")
      FetchContent_Declare(
        pybind11
        GIT_REPOSITORY https://github.com/pybind/pybind11.git
        GIT_TAG        v2.10.4
      )
      FetchContent_MakeAvailable(pybind11)
    endif()
  else()
    # cross-compile: always fetch pybind11 as a subproject so pybind11's CMake
    # logic will see the cache variables we set earlier (and won't probe host Python).
    message(STATUS "Cross-compiling: providing pybind11 via FetchContent (avoid pybind11Config probing)")
    FetchContent_Declare(
      pybind11
      GIT_REPOSITORY https://github.com/pybind/pybind11.git
      GIT_TAG        v2.10.4
    )
    FetchContent_MakeAvailable(pybind11)
  endif()
endif()


if(CMAKE_BUILD_TYPE STREQUAL "Debug")
  add_definitions(-DDEBUG_MODE)
endif()

include_directories(bla/src)
include_directories(bla/HPC/src)
include_directories(bla/HPC/concurrentqueue)

# Include subdirectories
add_subdirectory(helper)
add_subdirectory(Elements)
add_subdirectory(nonlinfunc)
add_subdirectory(src)
include_directories(helper)

# Add the main executable
add_executable(main main.cc)

# Link libraries to the main executable
target_link_libraries(main PRIVATE helper Elements nonlinfunc src)

# pybind11 module
pybind11_add_module(rigid_body_FEM bind.cc)
target_link_libraries(rigid_body_FEM PUBLIC Elements nonlinfunc src)

# (Optional) any extra packaging / install logic follows...
